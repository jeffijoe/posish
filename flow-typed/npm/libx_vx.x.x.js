// flow-typed signature: 2c4b0052c4302460ae69cd76f73886f9
// flow-typed version: <<STUB>>/libx_v^0.2.2/flow_v0.53.1

/**
 * This is an autogenerated libdef stub for:
 *
 *   'libx'
 *
 * Fill this stub out by replacing all the `any` types.
 *
 * Once filled out, we encourage you to share your work with the
 * community by sending a pull request to:
 * https://github.com/flowtype/flow-typed
 */

import type { IObservableArray } from 'mobx'

declare module 'libx' {

  /**
   * Used in various Lodash functions such as `map`, `filter`..
   */
  declare type Iteratee<T, M> = (input: T, index: number) => M

  /**
   * Called when the collection wants to add a new item.
   */
  declare type CreateFunc<T> = (input: Object, opts: CollectionOptions<T>) => T;

  /**
   * Called when the collection wants to update an existing item.
   */
  declare type UpdateFunc<T> = (existing: T, input: Object, opts: CollectionOptions<T>) => T;

  /**
   * Function used for getting the ID of a particular input.
   */
  declare type GetId<T> = (obj: T, opts: CollectionOptions<T>) => any;

  /**
   * Collection options.
   */
  declare type CollectionOptions<T> = {
    /**
     * May be used by callbacks like `getModelId` and `getDataId`
     */
    idAttribute?: string;
    /**
     * Called when the collection wants to add a new item.
     */
    create?: CreateFunc<T>;
    /**
     * Called when the collection wants to update an existing item with more data.
     */
    update?: UpdateFunc<T>;
    /**
     * Used to get the ID of a model that was passed in. Whatever is returned from
     * this should be coercible to a string, and is used for indexing.
     */
    getModelId?: GetId<T>;
    /**
     * Used to get an ID from input data, used to determine whether to create
     * or update.
     */
    getDataId?: GetId<Object>;
  }

  declare interface Collection<T> {
    /**
     * The actual item map.
     */
    items: IObservableArray<T>;
    /**
     * Getter for the items length.
     */
    length: number;
    /**
     * Adds one or more models to the end of the collection.
     */
    add (models: T | T[]): Collection<T>;
    /**
     * Multi-version of `create`.
     */
    create (data: Object[], createOpts?: CollectionOptions<T>): T[];
    /**
     * Like `set`, but will add regardless of whether an id is present or not.
     * This has the added risk of resulting multiple model instances if you don't make sure
     * to update the existing model once you do have an id. The model id is what makes the whole
     * one-instance-per-entity work.
     */
    create (data: Object, createOpts?: CollectionOptions<T>): T;
    /**
     * Gets items by ids.
     */
    get (id: any[]): Array<?T>;
    /**
     * Gets a item by id.
     */
    get (id: any): ?T;
    /**
     * Same as the singular version, but with multiple.
     */
    set (data?: Object[], setOpts?: CollectionOptions<T>): ?T[];
    /**
     * Adds a single item and maps it using the mapper in the options.
     */
    set (data?: Object, setOpts?: CollectionOptions<T>): ?T;
    /**
     * Clears the collection.
     */
    clear(): Collection<T>;
    /**
     * Maps over the items.
     */
    map<M> (iteratee: Iteratee<T, M>): M[];
    /**
     * Filters the items.
     */
    filter (iteratee: Iteratee<T, boolean>): T[];
    /**
     * Determines if there are any items that match the predicate.
     */
    some (iteratee: Iteratee<T, boolean>): boolean;
    /**
     * Determines if all items match the predicate.
     */
    every (iteratee: Iteratee<T, boolean>): boolean;
    /**
     * Chunks the collection.
     */
    chunk (size?: number): Array<Array<T>>;
    /**
     * Reduces on the items.
     */
    reduce <R>(iteratee: Iteratee<T, R>, seed?: R): R;
    /**
     * Finds a particular item.
     */
    find (iteratee: Iteratee<T, boolean>): ?T;
    /**
     * Orders the items based on iteratees and orders.
     */
    orderBy (iteratees: Array<Iteratee<T, any>|Object|string>, orders?: Array<boolean|string>): T[];
    /**
     * Removes an item based on ID or the item itself.
     */
    remove (modelOrId: T | string): Collection<T>;
    /**
     * Slices the array.
     */
    slice (start?: number, end?: number): T[];
    /**
     * Moves an item from one index to another, using MobX's `move`.
     */
    move (fromIndex: number, toIndex: number): Collection<T>;
    /**
     * Returns the item at the specified index.
     */
    at (index: number): ?T;
    /**
     * Runs a `forEach` over the items and returns the collection.
     */
    forEach (iteratee: Iteratee<T, any>): Collection<T>;
  }

  declare type ModelCollectionOptions<TModel> = CollectionOptions<TModel> & {
    model: Class<TModel>;
    rootStore: any;
  }

  declare class Store {
    collection<TModel> (opts: ModelCollectionOptions<TModel>): Collection<TModel>;
  }
}
